{
  "_format": "hh3-sol-build-info-1",
  "id": "solc-0_8_30-2c114b9512aec61474bdb0ab9baa6c7e5bb759fd",
  "solcVersion": "0.8.30",
  "solcLongVersion": "0.8.30+commit.73712a01",
  "userSourceNameMap": {
    "contracts/core/TerritoryStaking.sol": "project/contracts/core/TerritoryStaking.sol"
  },
  "input": {
    "language": "Solidity",
    "settings": {
      "evmVersion": "prague",
      "optimizer": {
        "enabled": true,
        "runs": 200
      },
      "outputSelection": {
        "*": {
          "": [
            "ast"
          ],
          "*": [
            "abi",
            "evm.bytecode",
            "evm.deployedBytecode",
            "evm.methodIdentifiers",
            "metadata"
          ]
        }
      },
      "remappings": [
        "project/:@openzeppelin/contracts/=npm/@openzeppelin/contracts@5.4.0/",
        "project/:@openzeppelin/contracts/=npm/@openzeppelin/contracts@5.4.0/"
      ],
      "viaIR": true
    },
    "sources": {
      "npm/@openzeppelin/contracts@5.4.0/access/Ownable.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (access/Ownable.sol)\n\npragma solidity ^0.8.20;\n\nimport {Context} from \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * The initial owner is set to the address provided by the deployer. This can\n * later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    /**\n     * @dev The caller account is not authorized to perform an operation.\n     */\n    error OwnableUnauthorizedAccount(address account);\n\n    /**\n     * @dev The owner is not a valid owner account. (eg. `address(0)`)\n     */\n    error OwnableInvalidOwner(address owner);\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the address provided by the deployer as the initial owner.\n     */\n    constructor(address initialOwner) {\n        if (initialOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(initialOwner);\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        if (owner() != _msgSender()) {\n            revert OwnableUnauthorizedAccount(_msgSender());\n        }\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        if (newOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
      },
      "npm/@openzeppelin/contracts@5.4.0/utils/Context.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n"
      },
      "npm/@openzeppelin/contracts@5.4.0/utils/ReentrancyGuard.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/ReentrancyGuard.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If EIP-1153 (transient storage) is available on the chain you're deploying at,\n * consider using {ReentrancyGuardTransient} instead.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant NOT_ENTERED = 1;\n    uint256 private constant ENTERED = 2;\n\n    uint256 private _status;\n\n    /**\n     * @dev Unauthorized reentrant call.\n     */\n    error ReentrancyGuardReentrantCall();\n\n    constructor() {\n        _status = NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        _nonReentrantBefore();\n        _;\n        _nonReentrantAfter();\n    }\n\n    function _nonReentrantBefore() private {\n        // On the first call to nonReentrant, _status will be NOT_ENTERED\n        if (_status == ENTERED) {\n            revert ReentrancyGuardReentrantCall();\n        }\n\n        // Any calls to nonReentrant after this point will fail\n        _status = ENTERED;\n    }\n\n    function _nonReentrantAfter() private {\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = NOT_ENTERED;\n    }\n\n    /**\n     * @dev Returns true if the reentrancy guard is currently set to \"entered\", which indicates there is a\n     * `nonReentrant` function in the call stack.\n     */\n    function _reentrancyGuardEntered() internal view returns (bool) {\n        return _status == ENTERED;\n    }\n}\n"
      },
      "project/contracts/core/TerritoryStaking.sol": {
        "content": "// SPDX-License-Identifier: MIT \npragma solidity 0.8.30;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\nimport \"../interfaces/IAntNFT.sol\";\nimport \"../interfaces/IColonyManager.sol\";\nimport \"../libraries/BattleCalculator.sol\"; // Make sure to import this\n\n/**\n * @title TerritoryStaking\n * @dev Manages territory staking, claiming, and battles\n * Compatible with OpenZeppelin 5.0 (Counters.sol removed)\n */\ncontract TerritoryStaking is Ownable, ReentrancyGuard {\n    // Territory tiers\n    uint256 public constant TIER_1_SLOTS = 1;\n    uint256 public constant TIER_2_SLOTS = 3;\n    uint256 public constant TIER_3_SLOTS = 5;\n    uint256 public constant TIER_4_SLOTS = 10;\n    uint256 public constant TIER_5_SLOTS = 20;\n    \n    uint256 public constant TIER_1_BASE_REWARD = 0.005 ether;\n    uint256 public constant TIER_2_BASE_REWARD = 0.015 ether;\n    uint256 public constant TIER_3_BASE_REWARD = 0.03 ether;\n    uint256 public constant TIER_4_BASE_REWARD = 0.07 ether;\n    uint256 public constant TIER_5_BASE_REWARD = 0.15 ether;\n    \n    uint256 public constant MAX_TERRITORIES_PER_PLAYER = 5;\n    uint256 public constant CLAIM_COOLDOWN = 1 days;\n    uint256 public constant BATTLE_COOLDOWN = 12 hours;\n    uint256 public constant BATTLE_TIMEOUT = 15 minutes;\n    \n    // Structs\n    struct Territory {\n        uint256 id;\n        uint256 tier;\n        address owner;\n        uint256[] stakedAnts;\n        uint256 lastClaimTime;\n        uint256 totalPower;\n        bool isActive;\n    }\n    \n    struct BattleRequest {\n        address attacker;\n        uint256 territoryId;\n        uint256[] attackerAnts;\n        uint256 requestTime;\n        bool resolved;\n    }\n    \n    // State variables - REPLACED Counters.Counter with uint256\n    uint256 private _nextTerritoryId = 1; // Start from 1 (0 is invalid)\n    \n    mapping(uint256 => Territory) public territories;\n    mapping(address => uint256[]) public playerTerritories;\n    mapping(uint256 => BattleRequest) public battleRequests;\n    mapping(address => uint256) public lastBattleTime;\n    \n    // Contract references\n    IAntNFT public antNFT;\n    IColonyManager public colonyManager;\n    \n    // Events\n    event TerritoryCreated(uint256 indexed territoryId, uint256 tier);\n    event TerritoryStaked(uint256 indexed territoryId, address indexed owner, uint256[] antIds);\n    event TerritoryUnstaked(uint256 indexed territoryId, address indexed owner);\n    event ResourcesClaimed(address indexed owner, uint256 territoryId, uint256 amount);\n    event BattleInitiated(uint256 indexed battleId, address attacker, uint256 territoryId);\n    event BattleResolved(uint256 indexed battleId, address winner, uint256 loot);\n    \n    constructor(address _antNFT, address _colonyManager) Ownable(msg.sender) {\n        antNFT = IAntNFT(_antNFT);\n        colonyManager = IColonyManager(_colonyManager);\n        \n        // Create initial territories\n        for (uint256 i = 0; i < 10; i++) {\n            _createTerritory(1); // Tier 1 territories\n        }\n        for (uint256 i = 0; i < 5; i++) {\n            _createTerritory(2); // Tier 2 territories\n        }\n        for (uint256 i = 0; i < 3; i++) {\n            _createTerritory(3); // Tier 3 territories\n        }\n        _createTerritory(4); // Tier 4 territory\n        _createTerritory(5); // Tier 5 territory\n    }\n    \n    /**\n     * @dev Create a new territory (admin only)\n     */\n    function _createTerritory(uint256 tier) internal {\n        uint256 territoryId = _nextTerritoryId;\n        _nextTerritoryId++;\n        \n        territories[territoryId] = Territory({\n            id: territoryId,\n            tier: tier,\n            owner: address(0),\n            stakedAnts: new uint256[](0),\n            lastClaimTime: 0,\n            totalPower: 0,\n            isActive: true\n        });\n        \n        emit TerritoryCreated(territoryId, tier);\n    }\n    \n    /**\n     * @dev Stake ants in a territory\n     * @param territoryId Territory to stake\n     * @param antIds Array of ant token IDs to stake\n     */\n    function stakeAnts(uint256 territoryId, uint256[] calldata antIds) external nonReentrant {\n        Territory storage territory = territories[territoryId];\n        require(territory.isActive, \"Territory not active\");\n        require(territory.owner == address(0) || territory.owner == msg.sender, \"Not owner\");\n        require(antIds.length > 0, \"No ants provided\");\n        \n        // Check tier slots\n        uint256 maxSlots = getTierSlots(territory.tier);\n        require(antIds.length <= maxSlots, \"Exceeds max slots\");\n        require(territory.stakedAnts.length + antIds.length <= maxSlots, \"Would exceed max slots\");\n        \n        // Check player territory limit\n        if (territory.owner == address(0)) {\n            require(playerTerritories[msg.sender].length < MAX_TERRITORIES_PER_PLAYER, \"Max territories reached\");\n        }\n        \n        // Verify ownership and stake ants\n        uint256 totalPower = territory.totalPower;\n        for (uint256 i = 0; i < antIds.length; i++) {\n            require(antNFT.ownerOf(antIds[i]) == msg.sender, \"Not owner of ant\");\n            require(!antNFT.isStaked(antIds[i]), \"Ant already staked\");\n            \n            // Stake ant\n            antNFT.setStaked(antIds[i], true);\n            territory.stakedAnts.push(antIds[i]);\n            \n            // Add power\n            totalPower += antNFT.getAntPower(antIds[i]);\n        }\n        \n        // Update territory\n        if (territory.owner == address(0)) {\n            territory.owner = msg.sender;\n            playerTerritories[msg.sender].push(territoryId);\n            territory.lastClaimTime = block.timestamp;\n        }\n        \n        territory.totalPower = totalPower;\n        \n        // Add experience to colony\n        colonyManager.addExperience(msg.sender, 10 * antIds.length);\n        \n        emit TerritoryStaked(territoryId, msg.sender, antIds);\n    }\n    \n    /**\n     * @dev Unstake ants from territory\n     * @param territoryId Territory to unstake from\n     * @param antIds Array of ant token IDs to unstake\n     */\n    function unstakeAnts(uint256 territoryId, uint256[] calldata antIds) external nonReentrant {\n        Territory storage territory = territories[territoryId];\n        require(territory.owner == msg.sender, \"Not owner\");\n        require(antIds.length > 0, \"No ants provided\");\n        \n        // Create mapping for quick lookup - FIXED: Use a simpler approach\n        bool[] memory toUnstake = new bool[](territory.stakedAnts.length);\n        \n        // Mark ants to unstake\n        for (uint256 i = 0; i < antIds.length; i++) {\n            for (uint256 j = 0; j < territory.stakedAnts.length; j++) {\n                if (territory.stakedAnts[j] == antIds[i]) {\n                    toUnstake[j] = true;\n                    break;\n                }\n            }\n        }\n        \n        // Remove ants and update power\n        uint256 totalPower = territory.totalPower;\n        uint256 newLength = 0;\n        \n        // Create new array without unstaked ants\n        uint256[] memory remainingAnts = new uint256[](territory.stakedAnts.length);\n        for (uint256 i = 0; i < territory.stakedAnts.length; i++) {\n            if (!toUnstake[i]) {\n                remainingAnts[newLength] = territory.stakedAnts[i];\n                newLength++;\n            } else {\n                // Unstake ant and subtract power\n                antNFT.setStaked(territory.stakedAnts[i], false);\n                totalPower -= antNFT.getAntPower(territory.stakedAnts[i]);\n            }\n        }\n        \n        // Update storage array\n        delete territory.stakedAnts;\n        for (uint256 i = 0; i < newLength; i++) {\n            territory.stakedAnts.push(remainingAnts[i]);\n        }\n        \n        territory.totalPower = totalPower;\n        \n        // If no ants left, territory becomes unowned\n        if (territory.stakedAnts.length == 0) {\n            // Remove from player territories\n            uint256[] storage playerTerr = playerTerritories[msg.sender];\n            for (uint256 i = 0; i < playerTerr.length; i++) {\n                if (playerTerr[i] == territoryId) {\n                    playerTerr[i] = playerTerr[playerTerr.length - 1];\n                    playerTerr.pop();\n                    break;\n                }\n            }\n            \n            territory.owner = address(0);\n            territory.lastClaimTime = 0;\n        }\n        \n        emit TerritoryUnstaked(territoryId, msg.sender);\n    }\n    \n    /**\n     * @dev Claim resources from territory\n     * @param territoryId Territory to claim from\n     */\n    function claimResources(uint256 territoryId) external nonReentrant {\n        Territory storage territory = territories[territoryId];\n        require(territory.owner == msg.sender, \"Not owner\");\n        require(block.timestamp >= territory.lastClaimTime + CLAIM_COOLDOWN, \"Claim cooldown active\");\n        \n        uint256 unclaimed = getUnclaimedRewards(territoryId);\n        require(unclaimed > 0, \"No rewards to claim\");\n        \n        territory.lastClaimTime = block.timestamp;\n        \n        // Send AVAX to owner\n        (bool success, ) = payable(msg.sender).call{value: unclaimed}(\"\");\n        require(success, \"Transfer failed\");\n        \n        emit ResourcesClaimed(msg.sender, territoryId, unclaimed);\n    }\n    \n    /**\n     * @dev Get unclaimed rewards for territory\n     */\n    function getUnclaimedRewards(uint256 territoryId) public view returns (uint256) {\n        Territory storage territory = territories[territoryId];\n        if (territory.owner == address(0) || territory.lastClaimTime == 0) {\n            return 0;\n        }\n        \n        uint256 timePassed = block.timestamp - territory.lastClaimTime;\n        uint256 daysPassed = timePassed / CLAIM_COOLDOWN;\n        \n        if (daysPassed == 0) return 0;\n        \n        uint256 baseReward = getTierBaseReward(territory.tier);\n        \n        // Calculate average power multiplier (avoid division by zero)\n        uint256 powerMultiplier = 100; // Default 100%\n        if (territory.stakedAnts.length > 0) {\n            powerMultiplier = (territory.totalPower * 100) / (territory.stakedAnts.length * 100);\n        }\n        \n        return baseReward * daysPassed * powerMultiplier / 100;\n    }\n    \n    /**\n     * @dev Initiate battle for territory\n     * @param territoryId Territory to attack\n     * @param attackerAnts Array of ant token IDs for attack\n     */\n    function initiateBattle(uint256 territoryId, uint256[] calldata attackerAnts) external nonReentrant {\n        Territory storage territory = territories[territoryId];\n        require(territory.isActive, \"Territory not active\");\n        require(territory.owner != msg.sender, \"Cannot attack own territory\");\n        require(attackerAnts.length > 0, \"No ants provided\");\n        require(block.timestamp >= lastBattleTime[msg.sender] + BATTLE_COOLDOWN, \"Battle cooldown\");\n        \n        // Verify attacker owns all ants and they're not staked\n        for (uint256 i = 0; i < attackerAnts.length; i++) {\n            require(antNFT.ownerOf(attackerAnts[i]) == msg.sender, \"Not owner of ant\");\n            require(!antNFT.isStaked(attackerAnts[i]), \"Ant is staked\");\n        }\n        \n        uint256 battleId = uint256(keccak256(abi.encodePacked(block.timestamp, msg.sender, territoryId)));\n        \n        battleRequests[battleId] = BattleRequest({\n            attacker: msg.sender,\n            territoryId: territoryId,\n            attackerAnts: attackerAnts,\n            requestTime: block.timestamp,\n            resolved: false\n        });\n        \n        lastBattleTime[msg.sender] = block.timestamp;\n        \n        emit BattleInitiated(battleId, msg.sender, territoryId);\n    }\n    \n    /**\n     * @dev Resolve battle (called by keeper or after timeout)\n     */\n    function resolveBattle(uint256 battleId) external nonReentrant {\n        BattleRequest storage request = battleRequests[battleId];\n        require(!request.resolved, \"Already resolved\");\n        require(block.timestamp >= request.requestTime + BATTLE_TIMEOUT, \"Battle not ready\");\n        \n        Territory storage territory = territories[request.territoryId];\n        \n        // Get powers\n        uint256[] memory attackerPowers = new uint256[](request.attackerAnts.length);\n        for (uint256 i = 0; i < request.attackerAnts.length; i++) {\n            attackerPowers[i] = antNFT.getAntPower(request.attackerAnts[i]);\n        }\n        \n        uint256[] memory defenderPowers = new uint256[](territory.stakedAnts.length);\n        for (uint256 i = 0; i < territory.stakedAnts.length; i++) {\n            defenderPowers[i] = antNFT.getAntPower(territory.stakedAnts[i]);\n        }\n        \n        // Calculate outcome - FIXED: Need to import BattleCalculator\n        // This assumes BattleCalculator is imported and used\n        // For now, simplified logic:\n        uint256 attackerTotal = 0;\n        uint256 defenderTotal = 0;\n        \n        for (uint256 i = 0; i < attackerPowers.length; i++) {\n            attackerTotal += attackerPowers[i];\n        }\n        for (uint256 i = 0; i < defenderPowers.length; i++) {\n            defenderTotal += defenderPowers[i];\n        }\n        \n        address winner;\n        uint256 loot = 0;\n        \n        // Simple battle resolution\n        if (attackerTotal > defenderTotal) {\n            // Attacker wins\n            winner = request.attacker;\n            loot = defenderTotal * 20 / 100; // 20% loot\n            \n            // Transfer territory ownership\n            if (territory.owner != address(0)) {\n                // Remove from old owner\n                uint256[] storage oldOwnerTerr = playerTerritories[territory.owner];\n                for (uint256 i = 0; i < oldOwnerTerr.length; i++) {\n                    if (oldOwnerTerr[i] == request.territoryId) {\n                        oldOwnerTerr[i] = oldOwnerTerr[oldOwnerTerr.length - 1];\n                        oldOwnerTerr.pop();\n                        break;\n                    }\n                }\n            }\n            \n            // Transfer to attacker\n            territory.owner = request.attacker;\n            playerTerritories[request.attacker].push(request.territoryId);\n            territory.lastClaimTime = block.timestamp;\n            \n            // Send loot\n            if (loot > 0) {\n                (bool success, ) = payable(request.attacker).call{value: loot}(\"\");\n                require(success, \"Loot transfer failed\");\n            }\n            \n        } else {\n            // Defender wins\n            winner = territory.owner;\n        }\n        \n        request.resolved = true;\n        \n        emit BattleResolved(battleId, winner, loot);\n    }\n    \n    /**\n     * @dev Get tier slots\n     */\n    function getTierSlots(uint256 tier) public pure returns (uint256) {\n        if (tier == 1) return TIER_1_SLOTS;\n        if (tier == 2) return TIER_2_SLOTS;\n        if (tier == 3) return TIER_3_SLOTS;\n        if (tier == 4) return TIER_4_SLOTS;\n        if (tier == 5) return TIER_5_SLOTS;\n        return 0;\n    }\n    \n    /**\n     * @dev Get tier base reward\n     */\n    function getTierBaseReward(uint256 tier) public pure returns (uint256) {\n        if (tier == 1) return TIER_1_BASE_REWARD;\n        if (tier == 2) return TIER_2_BASE_REWARD;\n        if (tier == 3) return TIER_3_BASE_REWARD;\n        if (tier == 4) return TIER_4_BASE_REWARD;\n        if (tier == 5) return TIER_5_BASE_REWARD;\n        return 0;\n    }\n    \n    /**\n     * @dev Get player territories\n     */\n    function getPlayerTerritories(address player) external view returns (uint256[] memory) {\n        return playerTerritories[player];\n    }\n    \n    /**\n     * @dev Get territory details\n     */\n    function getTerritoryDetails(uint256 territoryId) external view returns (\n        uint256 tier,\n        address owner,\n        uint256[] memory stakedAnts,\n        uint256 totalPower,\n        uint256 unclaimedRewards,\n        bool isActive\n    ) {\n        Territory storage territory = territories[territoryId];\n        return (\n            territory.tier,\n            territory.owner,\n            territory.stakedAnts,\n            territory.totalPower,\n            getUnclaimedRewards(territoryId),\n            territory.isActive\n        );\n    }\n    \n    // Admin function to create additional territories\n    function createTerritory(uint256 tier) external onlyOwner {\n        _createTerritory(tier);\n    }\n    \n    // Receive function to accept AVAX\n    receive() external payable {}\n}"
      },
      "project/contracts/interfaces/IAntNFT.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.30;\n\n/**\n * @title IAntNFT\n * @dev Interface for Ant NFT contract\n */\ninterface IAntNFT {\n    // Structs\n    struct Ant {\n        uint256 dna;\n        uint256 level;\n        uint256 experience;\n        uint256 breedCount;\n        uint256 birthTime;\n        uint256 lastBreedTime;\n        bool isStaked;\n        bool isSoulbound;\n    }\n    \n    // Events\n    event AntMinted(address indexed owner, uint256 indexed tokenId, uint256 dna, bool isStarter);\n    event AntBred(address indexed owner, uint256 indexed parent1, uint256 indexed parent2, uint256 newAntId);\n    event AntLeveledUp(uint256 indexed tokenId, uint256 newLevel);\n    event AntStaked(uint256 indexed tokenId, address indexed owner);\n    event AntUnstaked(uint256 indexed tokenId, address indexed owner);\n    event BreedingCostUpdated(uint256 newCost);\n    \n    // Core Functions\n    function mintStarterAnts() external;\n    function breedAnts(uint256 parent1Id, uint256 parent2Id) external payable;\n    function levelUp(uint256 tokenId) external;\n    function addExperience(uint256 tokenId, uint256 amount) external;\n    function setStaked(uint256 tokenId, bool staked) external;\n    function transferFrom(address from, address to, uint256 tokenId) external;\n    function burn(uint256 tokenId) external; // Add burn function\n    \n    // View Functions\n    function ownerOf(uint256 tokenId) external view returns (address);\n    function balanceOf(address owner) external view returns (uint256);\n    function getAntPower(uint256 tokenId) external view returns (uint256);\n    function getAntDetails(uint256 tokenId) external view returns (\n        uint256 dna,\n        uint256 level,\n        uint256 experience,\n        uint256 breedCount,\n        uint256 birthTime,\n        bool isStaked,\n        bool isSoulbound\n    );\n    function getOwnerAnts(address owner) external view returns (uint256[] memory);\n    function hasClaimedStarterAnts(address user) external view returns (bool);\n    function isStaked(uint256 tokenId) external view returns (bool);\n    \n    // Admin Functions\n    function setColonyManager(address _colonyManager) external;\n    function setTournamentSystem(address _tournamentSystem) external;\n    function updateBreedingCost(uint256 newCost) external;\n}"
      },
      "project/contracts/interfaces/IColonyManager.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.30;\n\n/**\n * @title IColonyManager\n * @dev Interface for Colony Manager contract\n */\ninterface IColonyManager {\n    // Structs\n    struct Colony {\n        uint256 level;\n        uint256 experience;\n        uint256 territoryCount;\n        uint256 totalPower;\n        uint256 lastResetTime;\n        uint256 resetCount;\n    }\n    \n    struct ResetBenefits {\n        uint256 hnyReward;\n        uint256 wisdomFragments;\n        bool hasReset;\n    }\n    \n    // Events\n    event ColonyReset(address indexed player, uint256 resetCount, uint256 hnyReward);\n    event ColonyLevelUp(address indexed player, uint256 newLevel);\n    event ExperienceGained(address indexed player, uint256 amount);\n    event TerritoryAdded(address indexed player, uint256 territoryId);\n    event TerritoryRemoved(address indexed player, uint256 territoryId);\n    \n    // Core Functions\n    function initializeColony() external;\n    function resetColony(uint256 paymentToken) external payable;\n    function addExperience(address player, uint256 amount) external;\n    \n    // View Functions\n    function getColonyDetails(address player) external view returns (\n        uint256 level,\n        uint256 experience,\n        uint256 territoryCount,\n        uint256 totalPower,\n        uint256 resetCount,\n        uint256 nextLevelXP\n    );\n    function getResetBenefits(address player) external view returns (\n        uint256 hnyReward,\n        uint256 wisdomFragments,\n        bool hasReset\n    );\n    function getResetCooldown(uint256 resetCount) external view returns (uint256);\n    function getResetCostHNY(uint256 resetNumber) external view returns (uint256);\n    function getResetCostAVAX(uint256 resetNumber) external view returns (uint256);\n    \n    // Territory management\n    function addTerritory(address player, uint256 territoryId) external;\n    function removeTerritory(address player, uint256 territoryId) external;\n    \n    // Admin Functions\n    function setAntNFT(address _antNFT) external;\n    function setHNYToken(address _hnyToken) external;\n    function setTerritoryStaking(address _territoryStaking) external;\n    function setTournamentSystem(address _tournamentSystem) external;\n}"
      },
      "project/contracts/libraries/BattleCalculator.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.30;\n\n/**\n * @title BattleCalculator\n * @dev Library for battle resolution logic\n * Gas optimized for on-chain calculations\n */\nlibrary BattleCalculator {\n    // Battle result enum\n    enum BattleResult {\n        OverwhelmingVictory,\n        NarrowVictory,\n        Stalemate,\n        Loss,\n        DevastatingDefeat\n    }\n    \n    // Terrain types\n    uint256 public constant TERRAIN_PLAINS = 0;\n    uint256 public constant TERRAIN_FOREST = 1;\n    uint256 public constant TERRAIN_MOUNTAIN = 2;\n    uint256 public constant TERRAIN_UNDERGROUND = 3;\n    \n    /**\n     * @dev Calculate battle outcome based on ant powers and terrain\n     */\n    function calculateOutcome(\n        uint256[] memory attackerPowers,\n        uint256[] memory defenderPowers,\n        uint256 terrain,\n        uint256 randomNonce\n    ) internal view returns (BattleResult, uint256 attackerCasualties, uint256 defenderCasualties) {\n        uint256 attackerTotal = 0;\n        uint256 defenderTotal = 0;\n        \n        // Sum powers\n        for (uint256 i = 0; i < attackerPowers.length; i++) {\n            attackerTotal += attackerPowers[i];\n        }\n        \n        for (uint256 i = 0; i < defenderPowers.length; i++) {\n            defenderTotal += defenderPowers[i];\n        }\n        \n        // Apply terrain bonuses\n        attackerTotal = applyTerrainBonus(attackerTotal, terrain, true, randomNonce);\n        defenderTotal = applyTerrainBonus(defenderTotal, terrain, false, randomNonce);\n        \n        // Calculate ratio\n        if (defenderTotal == 0) {\n            return (BattleResult.OverwhelmingVictory, 0, defenderPowers.length);\n        }\n        \n        uint256 ratio = (attackerTotal * 100) / defenderTotal;\n        \n        // Determine outcome\n        BattleResult result;\n        if (ratio > 150) {\n            result = BattleResult.OverwhelmingVictory;\n        } else if (ratio > 115) {\n            result = BattleResult.NarrowVictory;\n        } else if (ratio > 85) {\n            result = BattleResult.Stalemate;\n        } else if (ratio > 50) {\n            result = BattleResult.Loss;\n        } else {\n            result = BattleResult.DevastatingDefeat;\n        }\n        \n        // Calculate casualties\n        (attackerCasualties, defenderCasualties) = calculateCasualties(\n            attackerPowers.length,\n            defenderPowers.length,\n            ratio,\n            randomNonce\n        );\n        \n        return (result, attackerCasualties, defenderCasualties);\n    }\n    \n    /**\n     * @dev Apply terrain bonus to army power\n     */\n    function applyTerrainBonus(\n        uint256 power,\n        uint256 terrain,\n        bool isAttacker,\n        uint256 randomNonce\n    ) private view returns (uint256) {\n        // Random factor for unpredictability (-10% to +10%)\n        uint256 randomFactor = 90 + (uint256(keccak256(abi.encodePacked(block.timestamp, randomNonce))) % 21);\n        \n        // Terrain bonuses (simplified)\n        if (terrain == TERRAIN_FOREST && !isAttacker) {\n            // Defenders get bonus in forest\n            power = power * 115 / 100;\n        } else if (terrain == TERRAIN_MOUNTAIN && !isAttacker) {\n            power = power * 120 / 100;\n        } else if (terrain == TERRAIN_UNDERGROUND && !isAttacker) {\n            power = power * 110 / 100;\n        }\n        \n        // Apply random factor\n        power = power * randomFactor / 100;\n        \n        return power;\n    }\n    \n    /**\n     * @dev Calculate casualties based on battle ratio\n     */\n    function calculateCasualties(\n        uint256 attackerCount,\n        uint256 defenderCount,\n        uint256 ratio,\n        uint256 randomNonce\n    ) private pure returns (uint256 attackerLosses, uint256 defenderLosses) {\n        // Base casualties\n        if (ratio > 150) {\n            attackerLosses = 1;\n            defenderLosses = defenderCount;\n        } else if (ratio > 115) {\n            attackerLosses = attackerCount * 20 / 100;\n            defenderLosses = defenderCount * 60 / 100;\n        } else if (ratio > 85) {\n            attackerLosses = attackerCount * 30 / 100;\n            defenderLosses = defenderCount * 30 / 100;\n        } else if (ratio > 50) {\n            attackerLosses = attackerCount * 60 / 100;\n            defenderLosses = defenderCount * 20 / 100;\n        } else {\n            attackerLosses = attackerCount;\n            defenderLosses = 1;\n        }\n        \n        // Add randomness\n        uint256 random = uint256(keccak256(abi.encodePacked(randomNonce, ratio))) % 10;\n        if (random < 3) {\n            // Reduce losses\n            attackerLosses = attackerLosses * 90 / 100;\n            defenderLosses = defenderLosses * 90 / 100;\n        } else if (random > 6) {\n            // Increase losses\n            attackerLosses = attackerLosses * 110 / 100;\n            defenderLosses = defenderLosses * 110 / 100;\n        }\n        \n        // Ensure minimum and maximum bounds\n        if (attackerLosses > attackerCount) attackerLosses = attackerCount;\n        if (defenderLosses > defenderCount) defenderLosses = defenderCount;\n        if (attackerLosses == 0 && attackerCount > 0 && ratio < 100) attackerLosses = 1;\n        if (defenderLosses == 0 && defenderCount > 0 && ratio > 100) defenderLosses = 1;\n        \n        return (attackerLosses, defenderLosses);\n    }\n    \n    /**\n     * @dev Calculate loot amount based on battle result\n     */\n    function calculateLoot(\n        uint256 defenderResources,\n        BattleResult result\n    ) internal pure returns (uint256) {\n        if (result == BattleResult.OverwhelmingVictory) {\n            return defenderResources * 30 / 100; // 30% loot\n        } else if (result == BattleResult.NarrowVictory) {\n            return defenderResources * 20 / 100; // 20% loot\n        } else if (result == BattleResult.Stalemate) {\n            return defenderResources * 10 / 100; // 10% loot (mutual destruction)\n        }\n        \n        return 0; // No loot on loss\n    }\n}"
      }
    }
  }
}